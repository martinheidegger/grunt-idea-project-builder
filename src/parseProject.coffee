fs = require 'fs'
path = require 'path'
async = require 'async'
glob = require 'glob'
{utils: {parseXml}} = require('flash-build-api')

modules_xml = (data)->
    modules = []
    data.modules = modules
    return { project: { component: { modules: { module: (properties)->
        modules.push properties.filepath
    } } } }

named_dependency_xml = (data)->
    data.sourcePaths = []
    data.libPaths = []
    return {
        component: {
            library: {
                CLASSES: {
                    root: {}
                }
                JAVADOC: {}
                SOURCES: {
                    root: (properties)->
                        data.sourcePaths.push(properties.url)
                }
                jarDirectory: (properties)->
                    data.libPaths.push(properties.url)
            }
        }
    }

module_xml = (data)->
    swf                                  = {}
    swf.modules         = swfModules     = {}
    data.swf            = swf
    data.android        = androidModules = {}
    data.ios            = iosModules     = {}
    data["source-path"] = sourcePaths    = []
    data.libraryItems   = libraryItems   = []
    return {
        module: {
            component: (properties) ->
                if properties.name == "NewModuleRootManager"
                    return {
                        "exclude-output": null
                        content: {
                            sourceFolder: (properties)->
                                sourcePaths.push(properties.url)
                            excludeFolder: null
                        }
                        orderEntry: (properties)->
                            if properties.type == "module-library"
                                return {
                                    library: (properties)->
                                        if properties.type == "flex"
                                            libraryItems.push(libraryItem = {})
                                            return  {
                                                properties: (properties)->
                                                    libraryItem.id = properties.id
                                                CLASSES: {
                                                    root: (properties)->
                                                        libraryItem.url = properties.url
                                                }
                                                JAVADOC: null
                                                SOURCES: null
                                                jarDirectory: (properties)->
                                                    libraryItems.many = true
                                            }
                                        else
                                            return null
                                }
                            else
                                return null
                    }
                else if properties.name == "FlexBuildConfigurationManager"
                    return {
                        "compiler-options": {}
                        configurations: {
                            configuration: (properties) ->
                                if properties.name?
                                    moduleName = properties.name
                                    linkedDependencies = []
                                    namedDependencies = []
                                    module = {
                                        output: properties["output-folder"]+"/"+properties["output-file"]
                                        classes: [properties["main-class"]]
                                        linkedDependencies: linkedDependencies
                                        namedDependencies: namedDependencies
                                        additionalOptions: ''
                                    }
                                    swfModules[moduleName] = module

                                    createPackaging = (modules) ->
                                        return (properties)->
                                            if properties.enabled == "true"
                                                if properties['use-generated-descriptor'] == "true"
                                                    throw "Can not autogenerated a -app.xml file!"
                                                
                                                paths = []
                                                packaging = {
                                                    descriptor: properties['custom-descriptor-path']
                                                    'package-file-name': properties['package-file-name']
                                                    paths: paths
                                                }
                                                modules[moduleName] = packaging
                                                return {
                                                    'files-to-package': {
                                                        'FilePathAndPathInPackage': (properties)->
                                                            paths.push(properties)
                                                    }
                                                    AirSigningOptions: (properties)->
                                                        if packaging['use-temp-certificate']
                                                            throw "Can not use a temporary certificate!"
                                                        packaging.key = properties['keystore-path']
                                                        packaging['provisioning-profile'] = properties['provisioning-profile-path']
                                                        return null
                                                }
                                            else
                                                return null
                                    return {
                                        "compiler-options": {
                                            map: null
                                            option: (properties)->
                                                if properties.name == "additionalOptions"
                                                    return module.additionalOptions += properties.value
                                                return null
                                        }
                                        "packaging-android": createPackaging(androidModules)
                                        "packaging-ios": createPackaging(iosModules)
                                        "packaging-air-desktop": {}
                                        dependencies: (properties)->
                                            module["target-player"] = properties["target-player"]
                                            return {
                                                entries: {
                                                entry: (properties) ->
                                                    if properties['library-level']? && properties['library-level'] != 'project'
                                                        throw new Error("No idea what to do with a library-level that isn't 'project'")
                                                    library = {
                                                        id: properties["library-id"]
                                                        name: properties["library-name"]
                                                    }
                                                    if library.id?
                                                        linkedDependencies.push(library)
                                                    else if library.name?
                                                        namedDependencies.push(library)    
                                                    return {
                                                        dependency: (properties)->
                                                            library.linkage = properties.linkage
                                                    }
                                                }
                                                sdk: null
                                            }
                                    }
                                else
                                    return null
                        }
                    }
                else
                    return null
        }
    }

iml_file = (data)->
    return {
        module: (properties)->
            if properties.type != "Flex"
                throw "Can not process '#{properties.type}' modules"

            return {
                component: {
                    configurations: {
                        configuration: {
                            dependencies: (properties)->
                                return {
                                    sdk: null
                                }
                            "compiler-options": {}
                            "packaging-air-desktop": {}
                            "packaging-android": {}
                            "packaging-ios": {}
                        }
                    }
                    "compiler-options": {
                    }
                    "exclude-output": {
                    }
                }
            }
    }

_replaceModule = (targetPath, dir)->
    if targetPath?
        p = targetPath.replace(/\$MODULE_DIR\$/, dir)
        return path.relative(dir, p)
    else
        return null

_replaceProject = (targetPath, dir)->
    if targetPath?
        return targetPath.replace(/^file\:\/\//, "").replace(/\$PROJECT_DIR\$/, dir)
    else
        return null

_loadNamedDependency = (dependency, namedDependencyMap, ideaRoot)->
    return (onComplete)->
        dependencyPath = path.resolve(ideaRoot, "libraries/#{dependency}.xml")
        parseXml dependencyPath, named_dependency_xml, (error, result)->
            namedDependencyMap[dependency] = result.data
            onComplete(error, result)

_loadModule = (allModules, module, moduleDir, projectDir, ideaRoot, flexHome) ->
    return (onComplete)->
        parseXml module, module_xml, (error, moduleResult)->
            if error then onComplete(error)
            else
                namedDependencies = _getAllNamedDependencies(moduleResult.data.swf.modules)
                loadAllNamedDependencies = []
                namedDependencyMap = {}
                for dependency in namedDependencies
                    loadAllNamedDependencies.push _loadNamedDependency(dependency, namedDependencyMap, ideaRoot)

                async.series loadAllNamedDependencies, (error, tempResult)->
                    if error then onComplete(error)
                    else
                        try
                            namedDependencyMap = _resolveNamedDependencies(namedDependencyMap, projectDir)
                            _constructData(moduleResult, allModules, moduleDir, flexHome, namedDependencyMap, onComplete)
                        catch e
                            onComplete(e)

_getAllNamedDependencies = (modules)->
    namedMap = {}
    namedList = []
    for name, args of modules
        for namedDependency in args.namedDependencies
            name = namedDependency.name
            if !namedMap[name]?
                namedMap[name] = true
                namedList.push(name)
    return namedList

_resolveNamedDependencies = (namedDependencyMap, projectDir)->
    for name, namedDependency of namedDependencyMap
        namedDependency.sourcePaths = (
            for sourcePath in namedDependency.sourcePaths
                _replaceProject(sourcePath, projectDir)
        )

        namedDependency.libPaths    =  (
            for libPath in namedDependency.libPaths
                _replaceProject(libPath, projectDir)     
        )

        swcs = []
        for libPath in namedDependency.libPaths
            swcs = swcs.concat glob.sync("#{libPath}/*.swc")
        namedDependency.swcs = swcs
    return namedDependencyMap

_constructData = (result, allModules, moduleDir, flexHome, namedDependencyMap, onComplete)->

    libraryItems = {}

    for libraryItem in result.data.libraryItems
        url = libraryItem.url
        libraryItems[libraryItem.id] = _replaceModule(
            url.substr(0, url.length-2).replace(/^jar\:\/\//, ""),
            moduleDir
        )


    sourcePaths = []

    for sourcePath in result.data['source-path']
        sourcePaths.push(
            _replaceModule(
                sourcePath.replace(/^file\:\/\//, ""),
                moduleDir
            )
        )

    swfModules = allModules.swf ?= {}
    androidModules = allModules.android ?= {}
    iosModules =  allModules.ios ?= {}

    for name, args of result.data.swf.modules
        libraryPaths = []
        moduleSourcePaths = sourcePaths.concat()

        args.output = _replaceModule(args.output, moduleDir)

        files = []
        for clazz in args.classes
            for sourcePath in moduleSourcePaths
                classFileRelative = sourcePath+"/"+clazz+".as"
                classFile = path.resolve(moduleDir, classFileRelative)
                if fs.existsSync(classFile)
                    files.push(classFileRelative)
                    break
                classFileRelative = sourcePath+"/"+clazz+".mxml"
                classFile = path.resolve(moduleDir, classFileRelative)
                if fs.existsSync(classFile)
                    files.push(classFileRelative)
                    break
        
        for linkedDependency in args.linkedDependencies
            libraryItem = libraryItems[linkedDependency.id]
            libraryPaths.push libraryItem

        for namedDependency in args.namedDependencies
            library = namedDependencyMap[namedDependency.name]
            moduleSourcePaths = moduleSourcePaths.concat(library.sourcePaths)
            libraryPaths = libraryPaths.concat(library.swcs)

        args["source-path"] = moduleSourcePaths
        args.files = files
        args["static-link-runtime-shared-libraries"] = "true"
        delete args['classes']
        delete args['libraryItems']
        delete args['libraryPaths']
        delete args["linkedDependencies"]
        delete args['namedDependencies']
        if !args.flexHome then args.flexHome = flexHome

        if libraryPaths.length > 0
            args["compiler.library-path"] = libraryPaths

        swfModules[name] = {
            path: moduleDir
            args: args
        }

    try
        for name, args of result.data.ios
            iosModules[name]     = _createAirModule(name, args, moduleDir, swfModules[name], flexHome, swfModules)

        for name, args of result.data.android
            androidModules[name] = _createAirModule(name, args, moduleDir, swfModules[name], flexHome, swfModules)
    catch e
        console.info e.stack
    

    onComplete(null, allModules)

removeUndefined = (obj)->
    for name, val of obj
        if !val
            delete obj[name]
    return obj

_createAirModule = (name, args, moduleDir, swfModule, flexHome, swfModules)->
    outputFile = swfModules[name].args.output
    outDir = path.dirname(outputFile)
    extDirs = []
    if swfModule.args['compiler.library-path'] 
        for libPath in swfModule.args['compiler.library-path']
            libDir = path.dirname(libPath)
            if /\.ane/.test(libPath) and extDirs.indexOf(libDir) == -1 then extDirs.push(libDir)

    return {
        path: moduleDir
        args: removeUndefined 
            flexHome:               flexHome
            "package-file-name":    args['package-file-name']
            mainFile:               path.basename(outputFile)
            output:                 path.relative(".", path.resolve(outDir, path.basename(outputFile, ".swf")))
            descriptor:             path.relative(".", path.resolve(outDir, path.basename(outputFile, ".swf")+"-app.xml"))
            keystore:               _replaceModule(args.key, moduleDir)
            "provisioning-profile": _replaceModule(args["provisioning-profile"], moduleDir)
            inputDescriptor:        _replaceModule(args.descriptor, moduleDir)
            paths:                  _createAirPackagePaths(args, moduleDir, outputFile)
            extDirs:                extDirs
        
    }

_createAirPackagePaths = (args, moduleDir, outputFile)->
    paths = []

    for pathInfo in args.paths
        filePath = _replaceModule(pathInfo['file-path'], moduleDir)
        
        paths.push({
            'file-path': filePath
            'path-in-package': pathInfo['path-in-package']
        })

    paths.push({
        'file-path': outputFile
        'path-in-package': path.basename(outputFile)
    })

    return paths

module.exports = (folder, flexHome, onComplete)->
    root = path.resolve(folder, ".")
    ideaRoot = path.resolve(root, ".idea")
    fs.exists ideaRoot, (exists)->
        if !exists 
            onComplete("Folder does not contain an idea project")
        else 
            fs.stat ideaRoot, (error, stat)->
                if error
                    onComplete("Error while trying to figure out what sort of folder that is:"+error)
                else if stat && stat.isDirectory
                    parseXml path.resolve(ideaRoot, "modules.xml"), modules_xml, (error, result)->
                        if error
                            onComplete(error, null)
                        else
                            allModules = {}
                            moduleLoaders = []

                            for module in result.data.modules
                                module = _replaceProject(module, root)
                                moduleRoot = path.resolve(root, path.dirname(module))
                                moduleLoaders.push _loadModule(allModules, module, moduleRoot, root, ideaRoot, flexHome)
                            
                            async.parallel moduleLoaders, (error, result)->
                                onComplete(null, allModules)
                else
                    onComplete("Folder does not contain an idea project")