// Generated by CoffeeScript 1.6.2
var async, deepExtend, flashCompiler_xml, fs, glob, module_xml, modules_xml, named_dependency_xml, parseXml, path, removeUndefined, resolveSymlink, _constructData, _createAirModule, _createAirModules, _createAirPackagePaths, _createAllAirModules, _getAllNamedDependencies, _getAneContainingFolders, _getExtDirs, _loadModule, _loadNamedDependency, _ref, _replaceFiles, _replaceModule, _replaceProject, _resolveNamedDependencies, _searchClass, _searchClassFile;

fs = require('fs');

path = require('path');

async = require('async');

glob = require('glob');

_ref = require('flash-build-api').utils, parseXml = _ref.parseXml, resolveSymlink = _ref.resolveSymlink, deepExtend = _ref.deepExtend;

modules_xml = function(data) {
  var modules;

  modules = [];
  data.modules = modules;
  return {
    project: {
      component: {
        modules: {
          module: function(properties) {
            return modules.push(properties.filepath);
          }
        }
      }
    }
  };
};

named_dependency_xml = function(data) {
  data.sourcePaths = [];
  data.libPaths = [];
  return {
    component: {
      library: {
        CLASSES: {
          root: {}
        },
        JAVADOC: {},
        SOURCES: {
          root: function(properties) {
            return data.sourcePaths.push(properties.url);
          }
        },
        jarDirectory: function(properties) {
          return data.libPaths.push(properties.url);
        }
      }
    }
  };
};

flashCompiler_xml = function(data) {
  return {
    project: {
      component: function(properties) {
        if (properties.name === "FlexIdeProjectLevelCompilerOptionsHolder") {
          return {
            "compiler-options": {
              map: null,
              option: function(properties) {
                return data[properties.name] = properties.value;
              }
            }
          };
        } else {
          return null;
        }
      }
    }
  };
};

module_xml = function(data) {
  var airModules, androidModules, iosModules, libraryItems, sourcePaths, swf, swfModules, testPaths;

  swf = {};
  swf.modules = swfModules = {};
  data.swf = swf;
  data.android = androidModules = {};
  data.ios = iosModules = {};
  data.air = airModules = {};
  data["test-path"] = testPaths = [];
  data["source-path"] = sourcePaths = [];
  data.libraryItems = libraryItems = [];
  return {
    module: {
      component: function(properties) {
        if (properties.name === "NewModuleRootManager") {
          return {
            "exclude-output": null,
            content: {
              sourceFolder: function(properties) {
                if (properties.isTestSource === "true") {
                  return testPaths.push(properties.url);
                } else {
                  return sourcePaths.push(properties.url);
                }
              },
              excludeFolder: null
            },
            orderEntry: function(properties) {
              if (properties.type === "module-library") {
                return {
                  library: function(properties) {
                    var libraryItem;

                    if (properties.type === "flex") {
                      libraryItems.push(libraryItem = {});
                      return {
                        properties: function(properties) {
                          return libraryItem.id = properties.id;
                        },
                        CLASSES: {
                          root: function(properties) {
                            return libraryItem.url = properties.url;
                          }
                        },
                        JAVADOC: null,
                        SOURCES: null,
                        jarDirectory: function(properties) {
                          return libraryItems.many = true;
                        }
                      };
                    } else {
                      return null;
                    }
                  }
                };
              } else {
                return null;
              }
            }
          };
        } else if (properties.name === "FlexBuildConfigurationManager") {
          return {
            "compiler-options": {
              option: function(properties) {
                if (properties.name === "additionalOptions") {
                  return data.additionalOptions = properties.value;
                }
                return null;
              }
            },
            configurations: {
              configuration: function(properties) {
                var createPackaging, linkedDependencies, module, moduleName, namedDependencies;

                if (properties.name != null) {
                  moduleName = properties.name;
                  linkedDependencies = [];
                  namedDependencies = [];
                  module = {
                    output: properties["output-folder"] + "/" + properties["output-file"],
                    classes: [properties["main-class"]],
                    linkedDependencies: linkedDependencies,
                    namedDependencies: namedDependencies,
                    additionalOptions: ''
                  };
                  swfModules[moduleName] = module;
                  createPackaging = function(modules) {
                    return function(properties) {
                      var packaging, paths;

                      if ((!properties.hasOwnProperty("enabled") || properties.enabled === "true") && properties.hasOwnProperty('package-file-name')) {
                        if (properties['use-generated-descriptor'] === "true") {
                          throw "Can not autogenerated a -app.xml file!";
                        }
                        paths = [];
                        packaging = {
                          descriptor: properties['custom-descriptor-path'],
                          'package-file-name': properties['package-file-name'],
                          paths: paths
                        };
                        modules[moduleName] = packaging;
                        return {
                          'files-to-package': {
                            'FilePathAndPathInPackage': function(properties) {
                              return paths.push(properties);
                            }
                          },
                          AirSigningOptions: function(properties) {
                            if (packaging['use-temp-certificate']) {
                              throw "Can not use a temporary certificate!";
                            }
                            packaging.key = properties['keystore-path'];
                            packaging['provisioning-profile'] = properties['provisioning-profile-path'];
                            return null;
                          }
                        };
                      } else {
                        return null;
                      }
                    };
                  };
                  return {
                    "compiler-options": {
                      map: null,
                      option: function(properties) {
                        if (properties.name === "additionalOptions") {
                          return module.additionalOptions += properties.value;
                        }
                        return null;
                      }
                    },
                    "packaging-android": createPackaging(androidModules),
                    "packaging-ios": createPackaging(iosModules),
                    "packaging-air-desktop": createPackaging(airModules),
                    dependencies: function(properties) {
                      module["target-player"] = properties["target-player"];
                      return {
                        entries: {
                          entry: function(properties) {
                            var library;

                            if ((properties['library-level'] != null) && properties['library-level'] !== 'project') {
                              throw new Error("No idea what to do with a library-level that isn't 'project'");
                            }
                            library = {
                              id: properties["library-id"],
                              name: properties["library-name"]
                            };
                            if (library.id != null) {
                              linkedDependencies.push(library);
                            } else if (library.name != null) {
                              namedDependencies.push(library);
                            }
                            return {
                              dependency: function(properties) {
                                return library.linkage = properties.linkage;
                              }
                            };
                          }
                        },
                        sdk: null
                      };
                    }
                  };
                } else {
                  return null;
                }
              }
            }
          };
        } else {
          return null;
        }
      }
    }
  };
};

_replaceModule = function(targetPath, dir) {
  var p;

  if (targetPath != null) {
    p = targetPath.replace(/\$MODULE_DIR\$/, dir);
    return path.relative(dir, resolveSymlink(p));
  } else {
    return null;
  }
};

_replaceProject = function(targetPath, dir) {
  if (targetPath != null) {
    return targetPath.replace(/^file\:\/\//, "").replace(/\$PROJECT_DIR\$/, dir);
  } else {
    return null;
  }
};

_loadNamedDependency = function(dependency, namedDependencyMap, ideaRoot) {
  return function(onComplete) {
    var dependencyPath;

    dependencyPath = path.resolve(ideaRoot, "libraries/" + dependency + ".xml");
    return parseXml(dependencyPath, named_dependency_xml, function(error, result) {
      namedDependencyMap[dependency] = result.data;
      return onComplete(error, result);
    });
  };
};

_loadModule = function(allModules, module, moduleDir, projectDir, ideaRoot, flexHome, globalOptions) {
  return function(onComplete) {
    return parseXml(module, module_xml, function(error, moduleResult) {
      var dependency, loadAllNamedDependencies, namedDependencies, namedDependencyMap, _i, _len;

      if (error) {
        return onComplete(error);
      } else {
        namedDependencies = _getAllNamedDependencies(moduleResult.data.swf.modules);
        loadAllNamedDependencies = [];
        namedDependencyMap = {};
        for (_i = 0, _len = namedDependencies.length; _i < _len; _i++) {
          dependency = namedDependencies[_i];
          loadAllNamedDependencies.push(_loadNamedDependency(dependency, namedDependencyMap, ideaRoot));
        }
        return async.series(loadAllNamedDependencies, function(error, tempResult) {
          var e;

          if (error) {
            return onComplete(error);
          } else {
            try {
              namedDependencyMap = _resolveNamedDependencies(namedDependencyMap, projectDir);
              return _constructData(moduleResult, allModules, moduleDir, flexHome, namedDependencyMap, globalOptions, onComplete);
            } catch (_error) {
              e = _error;
              return onComplete(e);
            }
          }
        });
      }
    });
  };
};

_getAllNamedDependencies = function(modules) {
  var args, name, namedDependency, namedList, namedMap, _i, _len, _ref1;

  namedMap = {};
  namedList = [];
  for (name in modules) {
    args = modules[name];
    _ref1 = args.namedDependencies;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      namedDependency = _ref1[_i];
      name = namedDependency.name;
      if (namedMap[name] == null) {
        namedMap[name] = true;
        namedList.push(name);
      }
    }
  }
  return namedList;
};

_resolveNamedDependencies = function(namedDependencyMap, projectDir) {
  var libPath, name, namedDependency, sourcePath, swcs, _i, _len, _ref1;

  for (name in namedDependencyMap) {
    namedDependency = namedDependencyMap[name];
    namedDependency.sourcePaths = (function() {
      var _i, _len, _ref1, _results;

      _ref1 = namedDependency.sourcePaths;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        sourcePath = _ref1[_i];
        _results.push(_replaceProject(sourcePath, projectDir));
      }
      return _results;
    })();
    namedDependency.libPaths = (function() {
      var _i, _len, _ref1, _results;

      _ref1 = namedDependency.libPaths;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        libPath = _ref1[_i];
        _results.push(_replaceProject(libPath, projectDir));
      }
      return _results;
    })();
    swcs = [];
    _ref1 = namedDependency.libPaths;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      libPath = _ref1[_i];
      swcs = swcs.concat(glob.sync("" + libPath + "/*.swc"));
      swcs = swcs.concat(glob.sync("" + libPath + "/*.ane"));
    }
    namedDependency.swcs = swcs;
  }
  return namedDependencyMap;
};

_searchClassFile = function(sourcePath, clazz, moduleDir, ending) {
  var classFile, classFileRelative;

  classFileRelative = sourcePath + "/" + clazz + ("." + ending);
  classFile = path.resolve(moduleDir, classFileRelative);
  if (fs.existsSync(classFile)) {
    return classFileRelative;
  }
};

_searchClass = function(clazz, moduleDir, paths) {
  var filePath, pth, _i, _len;

  for (_i = 0, _len = paths.length; _i < _len; _i++) {
    pth = paths[_i];
    filePath = _searchClassFile(pth, clazz, moduleDir, "as") || _searchClassFile(pth, clazz, moduleDir, "mxml");
    if (filePath) {
      return filePath;
    }
  }
  return null;
};

_replaceFiles = function(entries, moduleDir) {
  var entry, result, _i, _len;

  result = [];
  for (_i = 0, _len = entries.length; _i < _len; _i++) {
    entry = entries[_i];
    result.push(_replaceModule(entry.replace(/^file\:\/\//, ""), moduleDir));
  }
  return result;
};

_constructData = function(result, allModules, moduleDir, flexHome, namedDependencyMap, globalOptions, onComplete) {
  var args, clazz, e, ext, externalLibraryPaths, file, files, hasTests, i, item, library, libraryItem, libraryItems, libraryPaths, linkedDependency, moduleSourcePaths, name, namedDependency, sourcePaths, swfModules, testPaths, testSwfModules, url, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;

  try {
    libraryItems = {};
    _ref1 = result.data.libraryItems;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      libraryItem = _ref1[_i];
      url = libraryItem.url;
      libraryItems[libraryItem.id] = _replaceModule(url.substr(0, url.length - 2).replace(/^jar\:\/\//, ""), moduleDir);
    }
    sourcePaths = _replaceFiles(result.data['source-path'], moduleDir);
    testPaths = _replaceFiles(result.data['test-path'], moduleDir);
    swfModules = (_ref2 = allModules.swf) != null ? _ref2 : allModules.swf = {};
    testSwfModules = (_ref3 = allModules.testSwf) != null ? _ref3 : allModules.testSwf = {};
    if ((_ref4 = allModules.ios) == null) {
      allModules.ios = {};
    }
    if ((_ref5 = allModules.testIos) == null) {
      allModules.testIos = {};
    }
    if ((_ref6 = allModules.android) == null) {
      allModules.android = {};
    }
    if ((_ref7 = allModules.testAndroid) == null) {
      allModules.testAndroid = {};
    }
    if ((_ref8 = allModules.air) == null) {
      allModules.air = {};
    }
    if ((_ref9 = allModules.testAir) == null) {
      allModules.testAir = {};
    }
    hasTests = result.data["test-path"].length > 0;
    _ref10 = result.data.swf.modules;
    for (name in _ref10) {
      args = _ref10[name];
      libraryPaths = [];
      externalLibraryPaths = [];
      moduleSourcePaths = sourcePaths.concat();
      args.output = _replaceModule(args.output, moduleDir);
      files = [];
      _ref11 = args.classes;
      for (_j = 0, _len1 = _ref11.length; _j < _len1; _j++) {
        clazz = _ref11[_j];
        file = _searchClass(clazz, moduleDir, moduleSourcePaths);
        if (file) {
          files.push(file);
        }
      }
      _ref12 = args.linkedDependencies;
      for (_k = 0, _len2 = _ref12.length; _k < _len2; _k++) {
        linkedDependency = _ref12[_k];
        libraryItem = libraryItems[linkedDependency.id];
        libraryPaths.push(libraryItem);
      }
      _ref13 = args.namedDependencies;
      for (_l = 0, _len3 = _ref13.length; _l < _len3; _l++) {
        namedDependency = _ref13[_l];
        library = namedDependencyMap[namedDependency.name];
        moduleSourcePaths = moduleSourcePaths.concat(library.sourcePaths);
        libraryPaths = libraryPaths.concat(library.swcs);
      }
      for (i = _m = _ref14 = libraryPaths.length - 1; _ref14 <= 0 ? _m <= 0 : _m >= 0; i = _ref14 <= 0 ? ++_m : --_m) {
        item = libraryPaths[i];
        if (/\.ane$/.test(item)) {
          libraryPaths.splice(i, 1);
          externalLibraryPaths.push(item);
        }
      }
      args["source-path"] = moduleSourcePaths;
      args.files = files;
      args["static-link-runtime-shared-libraries"] = "true";
      if (result.data.additionalOptions) {
        if ((_ref15 = args.additionalOptions) == null) {
          args.additionalOptions = "";
        }
        args.additionalOptions += " " + result.data.additionalOptions;
      }
      args.inheritedOptions = globalOptions.additionalOptions;
      delete args['classes'];
      delete args['libraryItems'];
      delete args['libraryPaths'];
      delete args["linkedDependencies"];
      delete args['namedDependencies'];
      if (!args.flexHome) {
        args.flexHome = flexHome;
      }
      if (libraryPaths.length > 0) {
        args["compiler.library-path"] = libraryPaths;
      }
      if (externalLibraryPaths.length > 0) {
        args["compiler.external-library-path"] = externalLibraryPaths;
      }
      swfModules[name] = {
        path: moduleDir,
        args: args
      };
      if (hasTests) {
        moduleSourcePaths = moduleSourcePaths.concat(testPaths);
        file = _searchClass("TestMain", moduleDir, moduleSourcePaths);
        if (file) {
          args = deepExtend(args, {
            "source-path": moduleSourcePaths
          });
          args.files = [file];
          ext = path.extname(args.output);
          args.output = args.output.substr(0, args.output.length - ext.length) + ".test" + ext;
          testSwfModules[name] = {
            path: moduleDir,
            args: args
          };
        }
      }
    }
    try {
      _createAllAirModules(allModules, result.data, args, moduleDir, flexHome, false);
      if (hasTests) {
        _createAllAirModules(allModules, result.data, args, moduleDir, flexHome, true);
      }
    } catch (_error) {
      e = _error;
      onComplete(e.stack);
      return;
    }
    return onComplete(null, allModules);
  } catch (_error) {
    e = _error;
    console.error(e.stack);
    throw e;
  }
};

_createAllAirModules = function(allModules, allModuleArgs, args, moduleDir, flexHome, tests) {
  var airModules, androidModules, iosModules, swfModules;

  if (tests) {
    swfModules = allModules.testSwf;
    iosModules = allModules.testIos;
    androidModules = allModules.testAndroid;
    airModules = allModules.testAir;
  } else {
    swfModules = allModules.swf;
    iosModules = allModules.ios;
    androidModules = allModules.android;
    airModules = allModules.air;
  }
  _createAirModules(iosModules, allModuleArgs.ios, args, moduleDir, swfModules, flexHome);
  _createAirModules(androidModules, allModuleArgs.android, args, moduleDir, swfModules, flexHome);
  return _createAirModules(airModules, allModuleArgs.air, args, moduleDir, swfModules, flexHome);
};

_createAirModules = function(modules, moduleArgs, args, moduleDir, swfModules, flexHome) {
  var name, _results;

  _results = [];
  for (name in moduleArgs) {
    args = moduleArgs[name];
    _results.push(modules[name] = _createAirModule(args, moduleDir, swfModules[name], flexHome));
  }
  return _results;
};

removeUndefined = function(obj) {
  var name, val;

  for (name in obj) {
    val = obj[name];
    if (!val) {
      delete obj[name];
    }
  }
  return obj;
};

_createAirModule = function(args, moduleDir, swfModule, flexHome) {
  var outDir, outputFile, paths;

  outputFile = swfModule.args.output;
  outDir = path.dirname(outputFile);
  paths = _createAirPackagePaths(args, moduleDir, outputFile);
  return {
    path: moduleDir,
    args: removeUndefined({
      flexHome: flexHome,
      "package-file-name": args['package-file-name'],
      mainFile: path.basename(outputFile),
      output: path.relative(".", path.resolve(outDir, path.basename(outputFile, ".swf"))),
      descriptor: path.relative(".", path.resolve(outDir, path.basename(outputFile, ".swf") + "-app.xml")),
      keystore: _replaceModule(args.key, moduleDir),
      "provisioning-profile": _replaceModule(args["provisioning-profile"], moduleDir),
      inputDescriptor: _replaceModule(args.descriptor, moduleDir),
      paths: paths,
      extDirs: _getExtDirs(swfModule.args['compiler.library-path'], paths)
    })
  };
};

_getExtDirs = function(libraryPaths, paths) {
  var aneFolders, pkgPath;

  aneFolders = _getAneContainingFolders(libraryPaths);
  aneFolders = _getAneContainingFolders((function() {
    var _i, _len, _results;

    _results = [];
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      pkgPath = paths[_i];
      _results.push(pkgPath['file-path']);
    }
    return _results;
  })(), aneFolders);
  return aneFolders;
};

_getAneContainingFolders = function(paths, aneFolders) {
  var dir, subPath, _i, _len;

  if (aneFolders == null) {
    aneFolders = [];
  }
  if (paths) {
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      subPath = paths[_i];
      dir = path.dirname(subPath);
      if (/\.ane$/.test(subPath) && aneFolders.indexOf(dir) === -1) {
        aneFolders.push(dir);
      }
    }
  }
  return aneFolders;
};

_createAirPackagePaths = function(args, moduleDir, outputFile) {
  var filePath, pathInfo, paths, _i, _len, _ref1;

  paths = [];
  _ref1 = args.paths;
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    pathInfo = _ref1[_i];
    filePath = _replaceModule(pathInfo['file-path'], moduleDir);
    paths.push({
      'file-path': filePath,
      'path-in-package': pathInfo['path-in-package']
    });
  }
  paths.push({
    'file-path': outputFile,
    'path-in-package': path.basename(outputFile)
  });
  return paths;
};

module.exports = function(folder, flexHome, onComplete) {
  var ideaRoot, root;

  root = path.resolve(folder, ".");
  ideaRoot = path.resolve(root, ".idea");
  return fs.exists(ideaRoot, function(exists) {
    if (!exists) {
      return onComplete("Folder does not contain an idea project");
    } else {
      return fs.stat(ideaRoot, function(error, stat) {
        if (error) {
          return onComplete("Error while trying to figure out what sort of folder that is:" + error);
        } else if (stat && stat.isDirectory) {
          return parseXml(path.resolve(ideaRoot, "modules.xml"), modules_xml, function(error, result) {
            if (error) {
              return onComplete(error, null);
            } else {
              return parseXml(path.resolve(ideaRoot, "flexCompiler.xml"), flashCompiler_xml, function(error, globalOptions) {
                var allModules, module, moduleLoaders, moduleRoot, _i, _len, _ref1;

                if (globalOptions == null) {
                  globalOptions = {
                    data: {}
                  };
                }
                allModules = {};
                moduleLoaders = [];
                _ref1 = result.data.modules;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  module = _ref1[_i];
                  module = _replaceProject(module, root);
                  moduleRoot = path.resolve(root, path.dirname(module));
                  moduleLoaders.push(_loadModule(allModules, module, moduleRoot, root, ideaRoot, flexHome, globalOptions.data));
                }
                return async.parallel(moduleLoaders, function(error, result) {
                  return onComplete(error, allModules);
                });
              });
            }
          });
        } else {
          return onComplete("Folder does not contain an idea project");
        }
      });
    }
  });
};
